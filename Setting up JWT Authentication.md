# Настраиваем аутентификацию пользователей с помощью JWT

В состав Django входит система аутентификации на базе сессий, которая работает "из коробки". В неё входят все модели, представления и шаблоны, необходимые для входа пользователей в систему и создания новых учётных записей. Но существует проблема: эта аутентификация Django работает только при использовании стандартного HTML цикла - запрос/ответ.

Что мы подразумеваем под "стандартным HTML циклом запрос/ответ"? Обычно, когда пользователь хочет осуществить какое-либо действие (например, создать новую учётную запись), он заполняет форму в своём веб браузере. Когда он нажимает кнопку "Отправить", браузер делает запрос (который включает данные, введенные пользователем в регистрацию форму) к серверу, сервер обрабатывает этот запрос и отвечает HTML кодом или перенаправляет браузер на новую страницу. Это то, что мы имеем ввиду, когда говорим о "полном обновлении страницы".

Почему важно знать, что встроенная аутентификация Django работает только со стандартным HTML циклом запрос/ответ? Потому что клиентское приложение, для которого мы создаём это API, не использует этот цикл. Вместо этого, клиентское приложение ожидает, что сервер вернет JSON вместо HTML. Возвращая JSON, мы позволяем клиентскому приложению, а не серверу, решать, что делать дальше. При использовании JSON цикла запрос/ответ, сервер принимает данные, обрабатывает их и возвращает ответ (как и в случае HTML цикла запрос/ответ), но ответ больше не управляет поведением браузера. Он просто сообщает нам результат выполнения запроса.

К счастью, команда, разрабатывающая Django, поняла, что тенденция веб разработки двигается в этом направлении. Они также учли, что некоторые проекты могут не захотеть использовать встроенные модели, представления и шаблоны. Вместо этого они могут захотеть использовать свои версии. Чтобы все усилия потраченные на разработку встроенной систему аутентификации Django не были потрачены впустую, они решили позволять использовать наиболее важные её части, при этом оставляя возможность настраивать конечный результат.

Мы более подробно рассмотрим этот вопрос позднее в этом разделе. Пока что, Вам необходимо знать, что:

1. Мы создадим свою собственную модель `User` вместо той, что используется в Django по умолчанию.
2. Нам нужно будет создать свои собственные представления, позволяющие возвращать JSON вместо HTML.
3. Поскольку мы не будем использовать HTML, нам не будут нужны стандартные Django шаблоны для входа в систему и регистрации.

Возможно Вы задаётесь вопросом - "Неужели придется писать систему аутентификации с нуля"? Для ответа не него вспомните то, о чём мы говорили раньше - Django позволяет использовать основные части аутентификации без использования стандартной системы аутентификации.

> Прочитайте раздел [Использование системы аутентификации Django](https://docs.djangoproject.com/es/1.11/topics/auth/default/) из документации Django, чтобы узнать больше о том как работает стандартная аутентификация Django.
> Прочитайте раздел [Модификация аутентификации в Django](https://docs.djangoproject.com/es/1.9/topics/auth/customizing/), чтобы лучше понять, что будет происходить в оставшейся части этой главы. Мы будем использовать информацию из этого раздела позднее.

## Аутентификациия с использованием сессий

По умолчанию Django использует сессии для аутентификации. Прежде чем мы продолжим поговорим о том, что это означает, почему это важно, что такое аутентификация с использованием токенов и JSON веб токены (сокращенно JWT), и какой способ аутентификации мы будем использовать в этом курсе.

В Django сессии хранятся в cookies. Эти сессии, а также некоторое встроенное связующее программное обеспечение и объекты запроса гарантируют, что у каждого запроса существует связанный с ним пользователь. К нему можно получить доступ через `request.user`. Когда пользователь вошёл в систему, `request.user` - это экземпляр класса `User`. Когда пользователь выходит из системы, `request.user` - это экземпляр класса `AnonymousUser`. Не зависимо от того аутентфиицирован пользователь или нет, `request.user` всегда будет существовать.

В чём отличие между экземплярами этих объектов? Упрощая скажем, что в любой момент, когда Вы хотите узнать аутентифицирован ли текущий пользователь, Вы можете использовать метод `request.user.is_authenticated()`, который вернет `True`, если пользователь аутентифицирован и `False`, если нет. Если `request.user` - это экземпляр `AnonymousUser`, то `request.user.is_authenticated()` всегда вернет `False`. Это позволяет разработчику (т. е. Вам!) вместо выражения `if request.user is not None and request.user.is_authenticated():` использовать `if request.user.is_authenticated():`. Уменьшение количества вводимых с клавиатуры символов не может не радовать в этом случае!

В нашем случае клиентское и серверное приложение будут запущены на разных серверах. Серверное приложение будет доступно по адресу `http://localhost:3000/`, а клиентское - по `http://localhost:5000/`. В этом случае браузер считает, что приложения запущены на разных доменах как если бы сервер был бы запущен на `http://www.server.com`, а клиент - на `http://www.client.com`. Мы не позволим внешним доменам получать доступ к нашим cookies, поэтому нам нужно найти другое, альтернативное решение, не использующее сессии.

Если Вам интересно почему мы не разрешаем доступ к нашим cookies, ознакомтесь со статьями, посвященными совместному использованию ресурсов между разными источникам (Cross-Origin Resource Sharing (CORS)) и межсайтовой подделкой запросов (Cross-Site Request Forgery (CSRF)), по приведенным ниже ссылкам. Если Вам не терпиться начать писать код, просто перейдите к следующему разделу.

> Чтобы узнать больше о Cross-Origin Resource Sharing (CORS), прочитайте эту статью [HTTP управление доступом (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
> Чтобы узнать больше о том как Django защищается от CSRF атак, прочитайте эту статью [Защита от межсайтовой подделки запроса](https://docs.djangoproject.com/ja/1.11/ref/csrf/).

## Аутентификация с использованием токенов

Наиболее распространенной альтернативой аутентификации с использованием сессий является аутентификация с использованием токенов, и мы будем использовать особую разновидность аутентификации с использованием токенов для защиты нашего приложения.

При использовании аутентификации с использованием токенов сервер выдаёт клиенту токен при успешном входе в систему. Этот токен уникален для каждого вошедшего в систему пользователя и хранится в базе данных вместе с ID пользователя. Подразумевается, что клиент будет посылать токен при последующих запросах, чтобы сервер мог идентифицировать пользователя. Сервер осуществляет идентификацию путем поиска в таблице базе данных, содержащей все созданные токены. Если найден соответствующий токен, сервер проверяет не устарел ли он. Если посланный токен не найден, то пользователь считается не аутентифицированным.

Поскольку токены хранятся в базе данных, а не в куки, аутентификация с использованием токенов соответствует нашим требованиям.

### Проверяем токены

Всегда существует возможность хранить не только ID пользователя в токене. Мы также можем хранить в нём такую информацию, как, например, дату, когда истекает токен. В этом учебном пособии мы будем проверять, то эта дата ещё не настала. В противном случае, считается, что токен устарел и не действителен. Поэтому мы удаляем его из базы данных и просим пользователя снова войти в систему.

## JSON веб токены

JSON веб токен (сокращенно JWT) является открытым стандартом ([RFC 7519](https://tools.ietf.org/html/rfc7519)), который определяет компактный и автономный способ безопасной передачи информации между двумя взаимодействующими сторонами. Вы можете считать JWT улучшенной версией токенов для аутентификации.

Помните, что выше я говорил об использовании особой разновидности аутентификации с использованием токенов? Я имел ввиду JWT.

> Чтобы узнать больше о JWT и о том как они работают, прочитайте эту статью [Введение в JSON веб токены](https://tools.ietf.org/html/rfc7519).

## Почему JSON веб токены лучше, чем обычные токены

Существует несколько преимуществ при использовании JWT вместо обычных токенов:
1) JWT - это открытый стандарт. Это означает, что все реализации JWT должны быть достаточно однотипными, что является преимуществом при работе с разными языками и технологиями. Обычные токены не имеют жёсткой привязки к стандартам, что позволяет разработчику решать как лучше всего реализовать токены.
2) JWT могут содержать всю информацию о пользователе, что довольно удобно для клиента.
3) О сложностях, связанных с реализацией алгоритмов, не стоит беспокоиться, поскольку уже существуют готовые бибилиотеки. Использовать самописную систему аутентификации довольно небезопасно, поэтому здесь мы полагаемся "на проверенные в бою" библиотеки, которым можно доверять.

## Создаём модель User (Пользователь)

Не пора ли начать писать код?

В файле `conduit/apps/authentication/models.py` хранятся модели, которые мы будем использовать для аутентификации. Если Вы уже склонировали репозиторий, то наверное заметили, что каталог `conduit/apps/authentication/` уже существует. Но в нём нет файла `models.py`. Создайте его.

> В этом курсе мы специально довольно кратко рассматриваем каждый фрагмент кода. Мы уверены, что используя комментарии в коде и ресурсы, на которые мы даём ссылки, Вы сможете найти всю необходумую Вам информацию.

Нам нужно будет добавить следующие импорты для создания классов `User` и `UserManager`, поэтому добавьте следующий код в начало файла:

```python
import jwt

from datetime import datetime, timedelta

from django.conf import settings
from django.contrib.auth.models import (
    AbstractBaseUser, BaseUserManager, PermissionsMixin
)
from django.db import models
```
Настраивая аутентификацию в Django необходимо указать, что Вы используете свой, пользовательский класс `Manager` с двумя методами: `create_user` и `create_superuser`. Чтобы узнать как настроить аутентификацию в Django, прочитайте раздел [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model).

Для начала создайте класс `UserManager`.

Введите код для класса `UserManager` в файл `conduit/apps/authentication/models.py` и обратите внимание на комментарии:

> Прочитайте раздел [Менеджеры](https://docs.djangoproject.com/en/1.10/topics/db/managers/), чтобы узнать что делает класс `Manager`.

```python
class UserManager(BaseUserManager):
    """
    Django требует, чтобы при создании нестандартной, пользовательской модели 
    пользователя использовался свой собственный класс Manager. Наследуясь от 
    `BaseUserManager`, мы заимствуем большую часть кода, которая используется Django
    при создании модели `User`.
    
    Все что нам остаётся сделать - это переопределить функцию `create_user`, которую
    мы будем использовать для создания объектов `User`.        
    """

    def create_user(self, username, email, password=None):
        """Метод создаёт и возвращает модель `User` 
        с электронной почтой, именем пользователя и паролем."""
        if username is None:
            raise TypeError('Users must have a username.')

        if email is None:
            raise TypeError('Users must have an email address.')

        user = self.model(username=username, email=self.normalize_email(email))
        user.set_password(password)
        user.save()

        return user

    def create_superuser(self, username, email, password):
        """Метод создаёт и возвращает модель `User` с правами 
        суперпользователя (админа)."""
        if password is None:
            raise TypeError('Superusers must have a password.')

        user = self.create_user(username, email, password)
        user.is_superuser = True
        user.is_staff = True
        user.save()

        return user
```

Теперь, когда мы создали класс `UserMenager`, мы можем создать модель `User`. Добавьте модель `User` в конец файла `conduit/apps/authentication/models.py`.

```python
class User(AbstractBaseUser, PermissionsMixin):
    # У каждого `User` должен быть уникальный человеко-понятный идентификатор,
    # который мы можем использовать для представления `User` в UI. Мы хотим
    # проиндексировать этот столбец в базе данных для ускорения поиска.    
    username = models.CharField(db_index=True, max_length=255, unique=True)

    # Нам также нужно каким-то образом связываться с пользователем
    # и способ идентификации пользователя при входе в систему. Поскольку нам в
    # любом случае необходим адрес электронной почты для связи с пользователем, 
    # мы будем также использовать email для входа в систему, поскольку он 
    # наиболее часто используется в качестве логина на момент написания учебного 
    # пособия.    
    email = models.EmailField(db_index=True, unique=True)

    # Когда пользователь больше не захочет использовать нашу платформу,     
    # он может захотеть удалить свою учетную запись. Для нас это будет проблемой, 
    # поскольку собранные о пользователе данные ценны для нас и мы не хотим удалять их. 
    # Мы просто предложим пользователям отключить их учетную запись вместо её удаления.
    # Таким образом, они больше не будут отображаться на сайте, но мы сможем продолжать
    # анализировать собранные данные.    
    is_active = models.BooleanField(default=True)

    # Флаг `is_staff` используется Django, чтобы определить кто может, 
    # а кто - нет входить в систему администрирования Django. Для большинства пользователей
    # значение этого флага всегда будет равно false.
    is_staff = models.BooleanField(default=False)

    # Временная метка, показывающая когда был создан этот объект.
    created_at = models.DateTimeField(auto_now_add=True)

    # Временная метка, показывающая, когда в последний раз обновлялся этот объект.
    updated_at = models.DateTimeField(auto_now=True)

    # При использовании нестандартной, пользовательской модели пользователя необходимо
    # определить дополнительные поля, требуемые Django.

    # Свойство `USERNAME_FIELD` указывает какое поле будет использоваться для входа в систему.
    # Здесь мы хотим использовать поле email.
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    # Сообщаем Django, что для работы с объектами этого типа нужно использовать 
    # определенный выше класс UserManager.
    objects = UserManager()

    def __str__(self):
        """
        Метод возвращает строковое предствление текущего `User`.

        Эта строка используется при выводе модели `User` в консоли.        
        """
        return self.email

    @property
    def token(self):
        """
        Метод позволяет нам получить токен пользователя, вызывая `user.token` 
        вместо `user.generate_jwt_token()`.

        Это возможно благодаря декоратору `@property`, указанному выше. `token` называется 
        "динамическим свойством".
        """
        return self._generate_jwt_token()

    def get_full_name(self):
        """
        Этот метод нужен Django, например, для работы с электронными письмами. 
        Чаще всего метод возвращает имя и фамилию пользователя. Но поскольку
        мы не храним настоящих имен пользователей, мы возвращаем вместо этого 
        их username.
        """
        return self.username

    def get_short_name(self):
        """
        Этот метод нужен Django, например, для работы с электронными письмами. 
        Чаще всего метод возвращает имя пользователя. Но поскольку
        мы не храним настоящих имен пользователей, мы возвращаем вместо этого 
        их username.
        """
        return self.username

    def _generate_jwt_token(self):
        """
        Генерирует JSON веб токен, который хранит ID данного пользователя, истекающий через 60 дней после создания.
        """
        dt = datetime.now() + timedelta(days=60)

        token = jwt.encode({
            'id': self.pk,
            'exp': int(dt.strftime('%s'))
        }, settings.SECRET_KEY, algorithm='HS256')

        return token.decode('utf-8')
```

Просмотрите приведенный выше фрагмент кода в течение нескольких минут, а затем сделайте следующее:

Если Вы хотите больше узнать о том как использовать нестандартную, пользовательскую аутентификацию в Django, Вам стоит изучить документацию. Материал, приведенный по ниже перечисленным ссылкам не является обязательным для изучения, но мы рекомендуем Вам ознакомиться с ним, если Вас заинтересовала эта тема:

* в разделе [models.CustomUser](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.CustomUser) указывается, что Django ожидает от нестандартной, пользовательской модели `User`.
* в моделях [models.AbstractBaseUser](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.AbstractBaseUser) и [models.PermissionsMixin](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.PermissionsMixin) уже реализованы некоторые из требований, указанных в предыдущей ссылке.
* в модели [models.BaseUserManager](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.BaseUserManager) представлены некотрые полезные инструменты, используя которые можно начать создавать свой класс `UserManager`.
* В [справочнике по полям модели](https://docs.djangoproject.com/en/1.10/ref/models/fields/) перечислены различные типы полей, поддерживаемые Django и параметры, которые можно передать в каждое поле (например, `db_index` и `unique`).

## Задаём параметр AUTH_USER_MODEL

По умолчанию Django предполагает, что для пользователей используется модель `django.contrib.auth.models.User`. Но мы хотим использовать нашу собственную, нестандартную модуль `User`. Поскольку мы создали класс `User`, теперь нам надо указать Django, что нужно использовать нашу модель `User` вместо той, которая используется по умолчанию.

> Настоятельно рекомендуем Вам прочитать главу документации [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model). Особенно разделы, отмеченные как "Предупреждения".

Если Вы уже осуществили миграцию базы данных перед тем как указать Django использовать нестандартную, пользовательскую модель `User`, Вам нужно удалить созданную базу данных и повторно осуществить миграции.

Задайте параметр `AUTH_USER_MODEL` в конце файла `conduit/settings.py`:

```python
# Сообщаем Django о созданной нами пользовательской модели `User`. Строка `authentication.User` сообщает Django, что нужно использовать модель `User` из модуля `authentication`. Этот модуль зарегистрирован выше, используя параметр `INSTALLED_APPS`.
AUTH_USER_MODEL = 'authentication.User'
```

## Создаём и запускаем миграции

По мере добавления новых моделей и изменении существующих, нам нужно будет обновлять базу данных, чтобы отразить эти изменения. Django использует миграции, чтобы сообщить базе данных, что что-то изменилось, и наша укажет базе данных о необходимости добавления новой таблицы для нашей нестандартной, пользовательской модели `User`.

> Замечание. Если Вы уже запускали команды `python manage.py makemigrations` или `python manage.py migrate`, Вам нужно удалить базу данных прежде чем продолжить. Если Вы используете SQLite в качестве базы данных, то просто удалите файл `db.sqlite3` из корневого каталога Вашего проекта. Django выдаст ошибку, если Вы измените параметр `AUTH_USER_MODEL` после создания базы данных, поэтому лучше всего удалить старую базу и создать новую.

Теперь можно создавать и применять миграции. После этого мы можем создать нашего первого пользователя.

Чтобы создать миграции, выполните в консоли следующую команду:

```
python manage.py makemigrations
```
Эта команда создаст миграции по умолчанию для нашего нового Django проекта. Но она не создаст миграции для новых приложений внутри нашего проекта. В первый раз, когда мы хотим создать миграции для нашего нового приложения, мы должны явно указать это.

Чтобы создать набор миграций для приложения `authentication`, запустите следующую команду:

```
python manage.py makemigrations authentication
```

Она создаст первоначальную миграцию для приложения `authentication`. В дальнейшем, когда Вы захотите создать миграцию для этого приложения, Вам достаточно будет запустить `python manage.py makemigrations`.

Теперь мы можем применить созданные миграции, выполнив следующую команду в консоли:

```
python manage.py migrate
```

В отличие от команды `makemigrations`, Вам никогда не нужно указывать приложение, для которого нужно применить миграции, при запуске команды `migrate`.

## Наш первый пользователь

Мы создали свою модель `User` и настроили и запустили базу данных. Следующий шаг - это создание нашего первого объекта `User`. Мы дадим этому пользователю права суперпользователя, чтобы с его помощью тестировать наш сайт.

Создайте вашего первого пользователя, выполнив в консоли следующую команду:

```
python manage.py createsuperuser
```

Django задаст Вам несколько вопросов - нужно будет ввести адрес электронной почты, имя пользователя и пароль. После этого будет создан новый пользователь. Поздравляем!

Чтобы проверить то, что пользователь действительно создался, давайте откроем оболочку Django из командной строки:

```
python manage.py shell_plus
```

Если Вы уже использовали Django, то Вы должны быть знакомы с командой `shell`, но не с `shell_plus`. Команда `shell_plus` доступна благодаря библиотеке `django-extensions`, которая была включена в склонированный Вами проект в начале этого учебного пособия. Библиотеку стоит использовать, поскольку она позволяет автоматически импортировать модели для каждого приложения в настройку `INSTALLED_APPS`. Её также можно настроить для автоматического импортирования других вспомогательных средств.

Как только откроется оболочка, выполните следующие команды:

> *Замечание*. Вам нужно вводить только команды из строк, перед которыми стоит символ приглашения командной строки `>>>`. Строки без `>>>` - это результат выполнения команды, выводимый в консоль.

```
>>> user = User.objects.first()
>>> user.username
‘james'
>>> user.token
'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0Njk0MDY2OTksImlkIjoxfQ.qSnwWVD4PJKhKxgLxY0H5mkTE51QnMWv_kqNJVau1go'
```

Если Вы всё сделали правильно, то должны увидеть результат аналогичный тому, который показан в данном фрагменте.

## Регистрируем новых пользователей

На данный момент пользователь ничего не может делать. Наша следующая задача - создать конечную точку для регистрации новых пользователей.

### RegistrationSerializer 

Начнём с создания файла `conduit/apps/authentication/serializers.py`, введя в него следующий код:

```python
from rest_framework import serializers

from .models import User


class RegistrationSerializer(serializers.ModelSerializer):
    ""Сериализует запросы на регистрацию и создаёт нового пользователя."""

    # Указываем, что пароль должен быть не менее 8 символов, 
    # не более 128 символов и не может быть прочитан клиентом    
    password = serializers.CharField(
        max_length=128,
        min_length=8,
        write_only=True
    )

    # У клиента не должно быть возможности посылать токен при запросе на регистрацию.
    # Для этого мы передаём в `token` параметр read-only.
    token = serializers.CharField(max_length=255, read_only=True)

    class Meta:
        model = User
        # Здесь перечисляются все поля, которые могут быть включаны в запрос или ответ
        # с учетом явно указанных выше полей.         
        fields = ['email', 'username', 'password', 'token']

    def create(self, validated_data):
        # Используем метод `create_user`? написанный ранее для создания нового пользователя.
        return User.objects.create_user(**validated_data)
```

Просмотрите этот код, уделяя особое внимание комментариям в нём, прежде чем продолжить чтение данного учебного пособия.

В вышеприведенном коде мы создали класс `RegistrationSerializer`, который наследуется от `serializers.ModelSerializer`. `serializers.ModelSerializer` - это абстракция `serializers.Serializer`, которую Вы возможно помните, если читали учебное пособие по Django REST фреймворку (DRF). `ModelSerializer` реализует некоторый функционал, необходимый для сериализации Django моделей вместо нас.

Также отметим, что сериализатор позволяет Вам определить два метода: `create` и `update`. В вышеприведенном примере мы создали наш собственный метод `create`, используя `User.objects.create_user`, но не определили метод `update`. В этом случае DRF будет использовать свой собственный стандартный метод `update` для обновления информации о пользователе.

### RegistrationAPIView

Теперь мы можем сериализовать запросы и ответы для регистрации пользователя. Затем мы создадим представление, которое будет использоваться как конечная точка, так что клиент должен будет перейти по URL, чтобы создать нового пользователя.

Создайте `conduit/apps/authentication/views.py` и введите следующий код:

```python
from rest_framework import status
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView

from .serializers import RegistrationSerializer


class RegistrationAPIView(APIView):
    # Позволяем любому пользователю (аутентифицированному или нет) переходить на эту конечную точку.
    permission_classes = (AllowAny,)
    serializer_class = RegistrationSerializer

    def post(self, request):
        user = request.data.get('user', {})

        # Код, используемый ниже для сериализатора создания, проверки и сохранения пользователя 
        # является стандартным и Вы будете их часто встречать на протяжении этого курса и позднее работая самостоятельно. 
        # Ознакомтесь с ними.
        serializer = self.serializer_class(data=user)
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

Давайте рассмотрим некоторые новые моменты в этом фрагменте:

1. Свойство `permission_classes` позволяет определить кто можем использовать эту конечную точку. Мы можем разрешить доступ только аутентифицированным пользователям или пользователям с правами администратора. Мы также можем разрешать доступ только аутентфиицированным пользователям или любому пользователю, основываясь на том является ли эта конечная точка "безопасной" - то есть конечная точка запрашивается с помощью `GET`, `HEAD` или `OPTIONS` запроса. Для изучения этого курса Вам нужно знать только о `GET` запросах.  Мы поговорим подробнее о `permissions_classes` позже.
2. Код, который Вы видите внутри `post` метода для сериализатора создания, проверки и сохранения пользователя является стандартным, при использовании DRF. Ознакомтесь с этим кодом, поскольку Вы будете часто его использовать.

> Прочитайте о [правах доступа](http://www.django-rest-framework.org/api-guide/permissions/) DRF.

Создайте файл `conduit/apps/authentication/urls.py` и добавьте в него следующий код:

```python
from django.conf.urls import url

from .views import RegistrationAPIView

urlpatterns = [
    url(r'^users/?$', RegistrationAPIView.as_view()),
]
```

Если Вы уже работали с другим фреймворком, таким как Rails, Вам может показаться странным, что первый аргумент, который мы передаём методу `url` - это регулярное выражение. К этому необходимо привыкнуть, но привыкнув, Вы увидите, что это мощный инструмент. Например, вышеприведенный маршрут будет соответствовать как `/users`, так и `/users/`. Это связано с тем, что в Django принято заканчивать маршруты обратным слешом. К сожалению, это противоречит нашим требованиям, согласоно которым не желательно использовать обратные слеши в конце путей. К счастью команда разработчиков Django приходит к нам на помощь. Другое отличие между Django и Rails заключается в том, что в Rails обычно все Ваши пути находятся в одном файле. Хотя можно поступить также в Django считается хорошей практикой разделять пути по отдельным файлам из-за причин, связанных с организацией проекта. Вот что мы сделали здесь. Теперь давайте добавим вышеприведенный файл в наш глобальный файл URL. Откройте `conduit/urls.py` и Вы увидите следующую строку в начале файла:

```python
from django.conf.urls import url
```

Первое, что мы сделаем, это испортируем метод `include` из `django.conf.urls`:

```python
-from django.conf.urls import url
+from django.conf.urls import include, url
```

Метод `include` позволяет добавить другой файл `urls.py` без необходимости выполнения такой работы как импортирование и повторное регистрирование путей в этом файле.

Ниже Вы увидите:

```python
urlpatterns = [
    url(r'^admin/', admin.site.urls),
]
```

ОБновим этот фрагмент, добавив наш новый файл `urls.py `:

```python
urlpatterns = [
    url(r'^admin/', admin.site.urls),
+
+    url(r'^api/', include('conduit.apps.authentication.urls', namespace='authentication')),
]
```

## Регистрируем пользователей с помощью Postman

Теперь когда мы создали модель `User` и добавили конечную точку для регистрации новых пользователей, мы быстро проверим её работоспособность, чтобы убедиться, что всё работает правильно. Для этого мы будем использовать инструмент Postman c заранее созданным набором конечных точек.

Если Вы никогда раньше не использовали Postman, ознакомьтесь со учебным пособием [Тестируем Conduit приложение, используя Postman](https://thinkster.io/tutorials/testing-backend-apis-with-postman).

Откройте Postman и используйте "Register" запрос внутри каталога "Auth", чтобы создать нового пользователя.

Превосходно! Впервые мы достигли какого-то реального прогресса!

Тем не менее кое-что нам нужно исправить. Заметьте, что ответ на запрос "Register" просто выдаёт всю информацию о пользователе. Наш клиент ожидает, что эта информация будет храниться в отдельном пространтсве имен `user`. Для этого мы создадим свой собственный пользовательский [DRF формирователь ответа от сервера](http://www.django-rest-framework.org/api-guide/renderers/).

## Отображаем объекты User

Создайте файл с названием `conduit/apps/authentication/renderers.py` со следующий содержимым:

```python
import json

from rest_framework.renderers import JSONRenderer


class UserJSONRenderer(JSONRenderer):
    charset = 'utf-8'

    def render(self, data, media_type=None, renderer_context=None):
        # Если был передан ключ `token` в запросе, то он будет байтовым объектом.
        # Байтовые объекты плохо сериализуются, поэтому нам надо его декодировать
        # прежде чем выдавать объект User.
        token = data.get('token', None)

        if token is not None and isinstance(token, bytes):
            # Как было сказано выше, мы декодируем `token` только в том случае,
            # если он является байтовым объектом.
            data['token'] = token.decode('utf-8')

        # Наконец мы можем выдать наши данные в пространстве имен "user".
        return json.dumps({
            'user': data
        })
```
В этом фрагменте кода нет ничего нового или интересного, поэтому прочитайте комментарии приведенные там и можете двигаться дальше.

Теперь откройте `conduit/apps/authentication/views.py` и импортируйте `UserJSONRenderer`, добавив следующую строку в начало Вашего файла:

```python
from .renderers import UserJSONRenderer
```

Вам также будет необходимо задать свойство `renderer_classes` класса `RegistrationAPIView` следующим образом:

```python
class RegistrationAPIView(APIView):
    permission_classes = (AllowAny,)
+    renderer_classes = (UserJSONRenderer,)
    serializer_class = RegistrationSerializer

    # … Остальная часть файла
```

С помощью `UserJSONRenderer` теперь используя запрос "Register" в Postman создайте новго пользователя. Заметьте, что в этот раз ответ находится внутри пространства имен "user".

## Реализация входа пользователей в систему

Поскольку пользователи теперь могут регистрироваться в приложении Conduit, нам необходим способ с помощью которого они могли бы войти в систему. В этом разделе мы добавим сериализатор и представление, необходимые для того, чтобы пользователи могли войти в систему. Мы также рассмотрим вопрос, связанный с тем как наш API должен обрабатывать ошибки.

## LoginSerializer

Откройте `conduit/apps/authentication/serializers.py` и добавьте следующий импорт в начало файла:

```python
from django.contrib.auth import authenticate
```

Затем создайте следующий сериализатор в этом же файле:

```python
class LoginSerializer(serializers.Serializer):
    email = serializers.CharField(max_length=255)
    username = serializers.CharField(max_length=255, read_only=True)
    password = serializers.CharField(max_length=128, write_only=True)
    token = serializers.CharField(max_length=255, read_only=True)

    def validate(self, data):
        # В методе `validate` происходит проверка "правильности" текущего экземпляра
        # `LoginSerializer`. Для случая входа пользователя в систему, это означает,
        # что он ввел адрес электронной почты и пароль и что введенная комбинация 
        # соответствует одному из пользователей в нашей базе данных.
        email = data.get('email', None)
        password = data.get('password', None)

        # Генерируем исключение, если 
        # не был введен адрес электронной почты.
        if email is None:
            raise serializers.ValidationError(
                'An email address is required to log in.'
            )

        # Генерируем исключение, если не был введен пароль.
        if password is None:
            raise serializers.ValidationError(
                'A password is required to log in.'
            )

        # Метод `authenticate` - это метод, предоставляемый Django, который осуществляет проверку 
        # правильности введенной комбинации адрес электронной почты/пароль. Заметьте, что Notice how
        # мы передаём `email` как значение `username`, поскольку в нашей модели User
        # в качестве `USERNAME_FIELD` мы использовали `email`.
        user = authenticate(username=email, password=password)

        # Если не было найдено ни одного пользователя соответствующего этой комбинации адрес электронной почты/пароль, то 
        # метод `authenticate` возвратит `None`. В этом случае генерируем исключение.
        if user is None:
            raise serializers.ValidationError(
                'A user with this email and password was not found.'
            )

        # Django предоставляет специальный флаг для нашей модели `User` - `is_active`. Он используется для того, 
        # чтобы сообщить нам, что пользователь забанен или деактивирован. Такого почти никогда не будет происходить, 
        # но всё равно этот флаг стоит проверять. Генерируем исключение в случае, если флаг не установлен.
        if not user.is_active:
            raise serializers.ValidationError(
                'This user has been deactivated.'
            )

        # Метод `validate` должен возвращать словарь проверенных данных.
        # Эти данные передаются методам `create` и `update`,
        # которые будут показаны ниже.
        return {
            'email': user.email,
            'username': user.username,
            'token': user.token
        }
```

После создания сериализатора можно переходить к созданию представления.

## LoginAPIView

Откройте `conduit/apps/authentication/views.py` и обновите следующую строку импорта:

```python
-from .serializers import RegistrationSerializer
+from .serializers import (
+    LoginSerializer, RegistrationSerializer
+)
```

Затем добавьте новое представление для входа в систему:

```python
class LoginAPIView(APIView):
    permission_classes = (AllowAny,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = LoginSerializer

    def post(self, request):
        user = request.data.get('user', {})

        # ОБратите внимание на то, что здесь мы не вызываем метод `serializer.save()`,
        # как делали раньше при создании конечной точки для регистрации.
        # Это связано с тем, что мы не хотим что-либо сохранять. Метод `validate` нашего 
        # сериализатора делает всё что нам нужно для реализации входа в систему.        
        serializer = self.serializer_class(data=user)
        serializer.is_valid(raise_exception=True)

        return Response(serializer.data, status=status.HTTP_200_OK)
```

Откройте `conduit/apps/authentication/urls.py` и обновите следующую строку импорта:

```python
-from .views import RegistrationAPIView
+from .views import LoginAPIView, RegistrationAPIView
```

Добавьте новое правило в список `urlpatterns`:

```python
urlpatterns = [
    url(r'^users/?$', RegistrationAPIView.as_view()),
+    url(r'^users/login/?$', LoginAPIView.as_view()),
]
```

## Осуществляем вход пользователя в систему с помощью Postman

На данный момент, пользователь может войти в систему, перейдя по адресу новой конечной точки для входа в систему. Давайте проверим это. Откройте Postman и используйте запрос Login, чтобы войти в систему под одним из пользователей, которого Вы создали ранее. Если попытка входа была успешной, то в ответ будет добавлен токен, который может использоваться в дальнейшем при выполнении запросов, требующих аутентификации пользователя.

Здесь нам нужно учесть кое-что ещё. Попробуйте использовать запрос Login с неправильной комбинацией адрес электронной почты/пароль. ОБратите внимание на выдаваемую ошибку. Здесь существует две проблемы.

Прежде всего, `non_field_errors` звучит странно. Обычно это означает что какое-либо из полей в сериализаторе не прошло валидацию. Поскольку мы переопределили метод `validate` вместо того, чтобы использовать конкретный метод, например, `validate_email`, Django REST фреймворк не может определить в каком поле возникла ошибка. По умолчанию выдаётся `non_field_errors` и поскольку наш клиент будет использовать этот ответ при возникновении ошибок, мы изменим его, выдавая `error`.

Во-вторых, клиент ожидает, что любые ошибки должны выдаваться в пространсвте имен `errors` в JSON ответе, подобно тому как мы создали пространство имен `user` для запросов входа в систему и регистрации. Мы сделаем это, переопределив используемую по умолчанию обработку ошибок в Django REST фреймворке.

## Переопределяем параметры EXCEPTION_HANDLER и NON_FIELD_ERRORS_KEY

Одна из настроек DRF называется `EXCEPTION_HANDLER` и возвращает словарь ошибок. Мы хоти, чтобы наши ошибки находились в пространстве имен `errors`, поэтому нам нужно переопределить `EXCEPTION_HANDLER`. Мы также переопределим `NON_FIELD_ERRORS_KEY` как было сказано ранее.

Давайте начнём с создания файла `conduit/apps/core/exceptions.py`, добавив в него следующий фрагмент кода:

```python
from rest_framework.views import exception_handler

def core_exception_handler(exc, context):
    # Если возникает исключение, которое мы здесь явно не обрабатываем, мы хотим,
    # поручить его обработку стандартному DRF обработчику. Если мы хотим обработать данный тип исключения,
    # то нам всё равно нужен доступ к ответу, генерируемому DRF,
    # поэтому в первую очередь необходимо получить его.
    response = exception_handler(exc, context)
    handlers = {
        'ValidationError': _handle_generic_error
    }
    # В строке кода после этого комментария видно как мы определяем
    # тип текущего исключения. Затем мы используем его, чтобы понять должны ли мы обрабатывать это We will use
    # исключение или можно позволить Django REST фреймворку сделать это за нас.    
    exception_class = exc.__class__.__name__

    if exception_class in handlers:
        # Если это исключение одно из тех, что мы хотим обрабатывать, то обрабатываем его. В противном случае,
        # возвращаем ответ, сгенерированный ранее стандартным обработчиком исключений.
        return handlers[exception_class](exc, context, response)

    return response

def _handle_generic_error(exc, context, response):
    # Это самый простой обработчик исключений, который мы можем создать.
    # Мы просто получаем ответ, сгенерированный DRF и помещаем его в пространство имен `errors`.
    response.data = {
        'errors': response.data
    }

    return response
```

После этого откройте `conduit/settings.py` и добавьте новый параметр под названием `REST_FRAMEWORK` в конец файла, следующим образом:

```python
REST_FRAMEWORK = {
    'EXCEPTION_HANDLER': 'conduit.apps.core.exceptions.core_exception_handler',
    'NON_FIELD_ERRORS_KEY': 'error',
}
```

Именно так мы переопределяем настройки в DRF. Мы добавим ещё один параметр немного позднее, когда начнём писать представления, требующие, чтобы пользователь был аутентифицирован.

Попробуйте отправить ещё раз запрос для входа в систему, используя Postman. При этом используйте неправильную комбинацию адреса электронной почты/пароля.

## Обновляем UserJSONRenderer

Ой! Все равно мы не смогли добиться того чего хотели. Теперь мы получаем ключ `errors`, но он находится в пространстве имен `user`. Это необходимо исправить.

Давайте обновим `UserJSONRenderer` и будем проверять наличие ключа `errors`, осуществляя выдачу информации по-другому в случае его наличия. Откройте `conduit/apps/authentication/renderers.py` и внесите в него следующие изменения:

```python
class UserJSONRenderer(JSONRenderer):
    charset = 'utf-8'

    def render(self, data, media_type=None, renderer_context=None):
+        # Если представление генерирует ошибку (например пользователь не может быть аутентифицирован
+        # или подобную, `data` будут содержать ключ `errors`. Мы хотим, чтобы используемый 
+        # по уолчанию JSONRenderer обрабатывал ошибки, поэтому необходимо 
+        # проверить наличие этого ключа в `data`.
+        errors = data.get('errors', None)

        # If we receive a `token` key in the response, it will be a
        # byte object. Byte objects don't serializer well, so we need to
        # decode it before rendering the User object.
        token = data.get('token', None)

+        if errors is not None:
+            # Как было сказано ранее, мы хотим, чтобы используемый по умолчанию
+            # JSONRenderer обрабатывал ошибки.
+            return super(UserJSONRenderer, self).render(data)

        if token is not None and isinstance(token, bytes):
            # We will decode `token` if it is of type
            # bytes.
            data['token'] = token.decode('utf-8')

        # Finally, we can render our data under the "user" namespace.
        return json.dumps({
            'user': data
        })
```

Теперь ещё раз отправьте запрос для входа в систему. В этот раз всё должно пройти нормально и ответ от сервера должен содержать ключ `errors` вместо `users`.

## Получаем и обновляем информацию о пользователях

Пользователи могут регистрировать новые учетные записи и входить в систему под этими записями. Теперь нужен способ с помощью которого они могли бы получать и обновлять свою информацию. Давайте реализуем его прежде чем перейдём к созданию профилей пользователей.

## UserSerializer

## UserRetrieveUpdateAPIView

Откройте `conduit/apps/authentication/views.py` и обновите импорты следующим образом:

```python
from rest_framework import status
+from rest_framework.generics import RetrieveUpdateAPIView
-from rest_framework.permissions import AllowAny
+from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from .renderers import UserJSONRenderer
from .serializers import (
-   LoginSerializer, RegistraitonSerializer
+    LoginSerializer, RegistrationSerializer, UserSerializer,
)
```

Ниже этих импортов создайте новое представление с названием `UserRetrieveUpdateAPIView`:

```python
class UserRetrieveUpdateAPIView(RetrieveUpdateAPIView):
    permission_classes = (IsAuthenticated,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = UserSerializer

    def retrieve(self, request, *args, **kwargs):
        # В этом методе мы не хотим ничего проверять или сохранять.
        # Вместо этого мы просто хотим, чтобы сериализатор преобразовал наш объект 
        # в JSON и послал клиенту.        
        serializer = self.serializer_class(request.user)

        return Response(serializer.data, status=status.HTTP_200_OK)

    def update(self, request, *args, **kwargs):
        serializer_data = request.data.get('user', {})

        # Вот где используется последовательность сериализации, 
        # проверки, сохранения, о которой мы говорили ранее.
        serializer = self.serializer_class(
            request.user, data=serializer_data, partial=True
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data, status=status.HTTP_200_OK)
```

Теперь перейдите в `conduit/apps/authentication/urls.py` и обновите импорты, добавив `UserRetrieveUpdateAPIView`:

```python
-from .views import LoginAPIView, RegistrationAPIView
+from .views import (
+    LoginAPIView, RegistrationAPIView, UserRetrieveUpdateAPIView
+)
```

И добавьте новый маршрут в `urlpatterns`:

```python
urlpatterns = [
+    url(r'^user/?$', UserRetrieveUpdateAPIView.as_view()),
    url(r'^users/?$', RegistrationAPIView.as_view()),
    url(r'^users/login/?$', LoginAPIView.as_view()),
]
```

Опять откройте Postman и отправьте запрос "Current User". Вы увидите ошибку, которая выглядит следующим образом:

```python
{
  "user": {
    "detail": "Authentication credentials were not provided."
  }
}
```

## Аутентифицируем пользователей

## Сообщаем DRF о нашем бекэнде для аутентификации

Мы должны явно указать Django REST фреймворку какой бекэнд для аутентификации мы хотим использовать, подобно тому, как мы указывали Django использовать свою собственную, нестандартную модель `User`.

Откройте `conduit/settings.py` и добавьте в словарь `REST_FRAMEWORK` новый ключ:

```python
REST_FRAMEWORK = {
     [...]
+
+    'DEFAULT_AUTHENTICATION_CLASSES': (
+        'conduit.apps.authentication.backends.JWTAuthentication',
+    ),
}
```

## Осуществляем получение и обновление информации о пользователях с помощью Postman

## Переходим к более интересным темам

Вот и конец этой главы. Мы создали модель для пользователя и три сериализатора для неё (RegistrationSerializer, LoginSerializer и UserSerializer - прим. переводчика). Добавлены четыре конечные точки, которые позволяют пользователям регистрироваться, входить в систему, получать и обновлять их пользовательские данные. Довольно неплохое начало!

В следующей главе мы создадим профили для наших пользователей. Вы наверное заметили, что модель `User` достаточно примитивная. Мы добавили в неё только то, что необходимо для аутентификации. Другая информация, например, биография и URL картинки с аватаром, войдет в модель `Profile`, которую мы создадим в следующей главе.
