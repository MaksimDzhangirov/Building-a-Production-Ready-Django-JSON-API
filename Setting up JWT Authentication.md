# Настраиваем аутентификацию пользователей с помощью JWT

В состав Django входит система аутентификации на базе сессий, которая работает "из коробки". В неё входят все модели, представления и шаблоны, необходимые для входа пользователей в систему и создания новых учётных записей. Но существует проблема: эта аутентификация Django работает только при использовании стандартного HTML цикла - запрос/ответ.

Что мы подразумеваем под "стандартным HTML циклом запрос/ответ"? Обычно, когда пользователь хочет осуществить какое-либо действие (например, создать новую учётную запись), он заполняет форму в своём веб браузере. Когда он нажимает кнопку "Отправить", браузер делает запрос (который включает данные, введенные пользователем в регистрацию форму) к серверу, сервер обрабатывает этот запрос и отвечает HTML кодом или перенаправляет браузер на новую страницу. Это то, что мы имеем ввиду, когда говорим о "полном обновлении страницы".

Почему важно знать, что встроенная аутентификация Django работает только со стандартным HTML циклом запрос/ответ? Потому что клиентское приложение, для которого мы создаём это API, не использует этот цикл. Вместо этого, клиентское приложение ожидает, что сервер вернет JSON вместо HTML. Возвращая JSON, мы позволяем клиентскому приложению, а не серверу, решать, что делать дальше. При использовании JSON цикла запрос/ответ, сервер принимает данные, обрабатывает их и возвращает ответ (как и в случае HTML цикла запрос/ответ), но ответ больше не управляет поведением браузера. Он просто сообщает нам результат выполнения запроса.

К счастью, команда, разрабатывающая Django, поняла, что тенденция веб разработки двигается в этом направлении. Они также учли, что некоторые проекты могут не захотеть использовать встроенные модели, представления и шаблоны. Вместо этого они могут захотеть использовать свои версии. Чтобы все усилия потраченные на разработку встроенной систему аутентификации Django не были потрачены впустую, они решили позволять использовать наиболее важные её части, при этом оставляя возможность настраивать конечный результат.

Мы более подробно рассмотрим этот вопрос позднее в этом разделе. Пока что, Вам необходимо знать, что:

1. Мы создадим свою собственную модель `User` вместо той, что используется в Django по умолчанию.
2. Нам нужно будет создать свои собственные представления, позволяющие возвращать JSON вместо HTML.
3. Поскольку мы не будем использовать HTML, нам не будут нужны стандартные Django шаблоны для входа в систему и регистрации.

Возможно Вы задаётесь вопросом - "Неужели придется писать систему аутентификации с нуля"? Для ответа не него вспомните то, о чём мы говорили раньше - Django позволяет использовать основные части аутентификации без использования стандартной системы аутентификации.

> Прочитайте раздел [Использование системы аутентификации Django](https://docs.djangoproject.com/es/1.11/topics/auth/default/) из документации Django, чтобы узнать больше о том как работает стандартная аутентификация Django.
> Прочитайте раздел [Модификация аутентификации в Django](https://docs.djangoproject.com/es/1.9/topics/auth/customizing/), чтобы лучше понять, что будет происходить в оставшейся части этой главы. Мы будем использовать информацию из этого раздела позднее.

## Аутентификациия с использованием сессий

По умолчанию Django использует сессии для аутентификации. Прежде чем мы продолжим поговорим о том, что это означает, почему это важно, что такое аутентификация с использованием токенов и JSON веб токены (сокращенно JWT), и какой способ аутентификации мы будем использовать в этом курсе.

В Django сессии хранятся в cookies. Эти сессии, а также некоторое встроенное связующее программное обеспечение и объекты запроса гарантируют, что у каждого запроса существует связанный с ним пользователь. К нему можно получить доступ через `request.user`. Когда пользователь вошёл в систему, `request.user` - это экземпляр класса `User`. Когда пользователь выходит из системы, `request.user` - это экземпляр класса `AnonymousUser`. Не зависимо от того аутентфиицирован пользователь или нет, `request.user` всегда будет существовать.

В чём отличие между экземплярами этих объектов? Упрощая скажем, что в любой момент, когда Вы хотите узнать аутентифицирован ли текущий пользователь, Вы можете использовать метод `request.user.is_authenticated()`, который вернет `True`, если пользователь аутентифицирован и `False`, если нет. Если `request.user` - это экземпляр `AnonymousUser`, то `request.user.is_authenticated()` всегда вернет `False`. Это позволяет разработчику (т. е. Вам!) вместо выражения `if request.user is not None and request.user.is_authenticated():` использовать `if request.user.is_authenticated():`. Уменьшение количества вводимых с клавиатуры символов не может не радовать в этом случае!

В нашем случае клиентское и серверное приложение будут запущены на разных серверах. Серверное приложение будет доступно по адресу `http://localhost:3000/`, а клиентское - по `http://localhost:5000/`. В этом случае браузер считает, что приложения запущены на разных доменах как если бы сервер был бы запущен на `http://www.server.com`, а клиент - на `http://www.client.com`. Мы не позволим внешним доменам получать доступ к нашим cookies, поэтому нам нужно найти другое, альтернативное решение, не использующее сессии.

Если Вам интересно почему мы не разрешаем доступ к нашим cookies, ознакомтесь со статьями, посвященными совместному использованию ресурсов между разными источникам (Cross-Origin Resource Sharing (CORS)) и межсайтовой подделкой запросов (Cross-Site Request Forgery (CSRF)), по приведенным ниже ссылкам. Если Вам не терпиться начать писать код, просто перейдите к следующему разделу.

> Чтобы узнать больше о Cross-Origin Resource Sharing (CORS), прочитайте эту статью [HTTP управление доступом (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
> Чтобы узнать больше о том как Django защищается от CSRF атак, прочитайте эту статью [Защита от межсайтовой подделки запроса](https://docs.djangoproject.com/ja/1.11/ref/csrf/).

## Аутентификация с использованием токенов

Наиболее распространенной альтернативой аутентификации с использованием сессий является аутентификация с использованием токенов, и мы будем использовать особую разновидность аутентификации с использованием токенов для защиты нашего приложения.

При использовании аутентификации с использованием токенов сервер выдаёт клиенту токен при успешном входе в систему. Этот токен уникален для каждого вошедшего в систему пользователя и хранится в базе данных вместе с ID пользователя. Подразумевается, что клиент будет посылать токен при последующих запросах, чтобы сервер мог идентифицировать пользователя. Сервер осуществляет идентификацию путем поиска в таблице базе данных, содержащей все созданные токены. Если найден соответствующий токен, сервер проверяет не устарел ли он. Если посланный токен не найден, то пользователь считается не аутентифицированным.

Поскольку токены хранятся в базе данных, а не в куки, аутентификация с использованием токенов соответствует нашим требованиям.

### Проверяем токены

Всегда существует возможность хранить не только ID пользователя в токене. Мы также можем хранить в нём такую информацию, как, например, дату, когда истекает токен. В этом учебном пособии мы будем проверять, то эта дата ещё не настала. В противном случае, считается, что токен устарел и не действителен. Поэтому мы удаляем его из базы данных и просим пользователя снова войти в систему.

## JSON веб токены

JSON веб токен (сокращенно JWT) является открытым стандартом ([RFC 7519](https://tools.ietf.org/html/rfc7519)), который определяет компактный и автономный способ безопасной передачи информации между двумя взаимодействующими сторонами. Вы можете считать JWT улучшенной версией токенов для аутентификации.

Помните, что выше я говорил об использовании особой разновидности аутентификации с использованием токенов? Я имел ввиду JWT.

> Чтобы узнать больше о JWT и о том как они работают, прочитайте эту статью [Введение в JSON веб токены](https://tools.ietf.org/html/rfc7519).

## Почему JSON веб токены лучше, чем обычные токены

Существует несколько преимуществ при использовании JWT вместо обычных токенов:
1) JWT - это открытый стандарт. Это означает, что все реализации JWT должны быть достаточно однотипными, что является преимуществом при работе с разными языками и технологиями. Обычные токены не имеют жёсткой привязки к стандартам, что позволяет разработчику решать как лучше всего реализовать токены.
2) JWT могут содержать всю информацию о пользователе, что довольно удобно для клиента.
3) О сложностях, связанных с реализацией алгоритмов, не стоит беспокоиться, поскольку уже существуют готовые бибилиотеки. Использовать самописную систему аутентификации довольно небезопасно, поэтому здесь мы полагаемся "на проверенные в бою" библиотеки, которым можно доверять.

## Создаём модель User (Пользователь)

Не пора ли начать писать код?

В файле `conduit/apps/authentication/models.py` хранятся модели, которые мы будем использовать для аутентификации. Если Вы уже склонировали репозиторий, то наверное заметили, что каталог `conduit/apps/authentication/` уже существует. Но в нём нет файла `models.py`. Создайте его.

> В этом курсе мы специально довольно кратко рассматриваем каждый фрагмент кода. Мы уверены, что используя комментарии в коде и ресурсы, на которые мы даём ссылки, Вы сможете найти всю необходумую Вам информацию.

Нам нужно будет добавить следующие импорты для создания классов `User` и `UserManager`, поэтому добавьте следующий код в начало файла:

```python
import jwt

from datetime import datetime, timedelta

from django.conf import settings
from django.contrib.auth.models import (
    AbstractBaseUser, BaseUserManager, PermissionsMixin
)
from django.db import models
```
Настраивая аутентификацию в Django необходимо указать, что Вы используете свой, пользовательский класс `Manager` с двумя методами: `create_user` и `create_superuser`. Чтобы узнать как настроить аутентификацию в Django, прочитайте раздел [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model).

Для начала создайте класс `UserManager`.

Введите код для класса `UserManager` в файл `conduit/apps/authentication/models.py` и обратите внимание на комментарии:

> Прочитайте раздел [Менеджеры](https://docs.djangoproject.com/en/1.10/topics/db/managers/), чтобы узнать что делает класс `Manager`.

```python
class UserManager(BaseUserManager):
    """
    Django требует, чтобы при создании нестандартной, пользовательской модели 
    пользователя использовался свой собственный класс Manager. Наследуясь от 
    `BaseUserManager`, мы заимствуем большую часть кода, которая используется Django
    при создании модели `User`.
    
    Все что нам остаётся сделать - это переопределить функцию `create_user`, которую
    мы будем использовать для создания объектов `User`.        
    """

    def create_user(self, username, email, password=None):
        """Метод создаёт и возвращает модель `User` 
        с электронной почтой, именем пользователя и паролем."""
        if username is None:
            raise TypeError('Users must have a username.')

        if email is None:
            raise TypeError('Users must have an email address.')

        user = self.model(username=username, email=self.normalize_email(email))
        user.set_password(password)
        user.save()

        return user

    def create_superuser(self, username, email, password):
        """Метод создаёт и возвращает модель `User` с правами 
        суперпользователя (админа)."""
        if password is None:
            raise TypeError('Superusers must have a password.')

        user = self.create_user(username, email, password)
        user.is_superuser = True
        user.is_staff = True
        user.save()

        return user
```

Теперь, когда мы создали класс `UserMenager`, мы можем создать модель `User`. Добавьте модель `User` в конец файла `conduit/apps/authentication/models.py`.

```python
class User(AbstractBaseUser, PermissionsMixin):
    # У каждого `User` должен быть уникальный человеко-понятный идентификатор,
    # который мы можем использовать для представления `User` в UI. Мы хотим
    # проиндексировать этот столбец в базе данных для ускорения поиска.    
    username = models.CharField(db_index=True, max_length=255, unique=True)

    # Нам также нужно каким-то образом связываться с пользователем
    # и способ идентификации пользователя при входе в систему. Поскольку нам в
    # любом случае необходим адрес электронной почты для связи с пользователем, 
    # мы будем также использовать email для входа в систему, поскольку он 
    # наиболее часто используется в качестве логина на момент написания учебного 
    # пособия.    
    email = models.EmailField(db_index=True, unique=True)

    # Когда пользователь больше не захочет использовать нашу платформу,     
    # он может захотеть удалить свою учетную запись. Для нас это будет проблемой, 
    # поскольку собранные о пользователе данные ценны для нас и мы не хотим удалять их. 
    # Мы просто предложим пользователям отключить их учетную запись вместо её удаления.
    # Таким образом, они больше не будут отображаться на сайте, но мы сможем продолжать
    # анализировать собранные данные.    
    is_active = models.BooleanField(default=True)

    # Флаг `is_staff` используется Django, чтобы определить кто может, 
    # а кто - нет входить в систему администрирования Django. Для большинства пользователей
    # значение этого флага всегда будет равно false.
    is_staff = models.BooleanField(default=False)

    # Временная метка, показывающая когда был создан этот объект.
    created_at = models.DateTimeField(auto_now_add=True)

    # Временная метка, показывающая, когда в последний раз обновлялся этот объект.
    updated_at = models.DateTimeField(auto_now=True)

    # При использовании нестандартной, пользовательской модели пользователя необходимо
    # определить дополнительные поля, требуемые Django.

    # Свойство `USERNAME_FIELD` указывает какое поле будет использоваться для входа в систему.
    # Здесь мы хотим использовать поле email.
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    # Сообщаем Django, что для работы с объектами этого типа нужно использовать 
    # определенный выше класс UserManager.
    objects = UserManager()

    def __str__(self):
        """
        Метод возвращает строковое предствление текущего `User`.

        Эта строка используется при выводе модели `User` в консоли.        
        """
        return self.email

    @property
    def token(self):
        """
        Метод позволяет нам получить токен пользователя, вызывая `user.token` 
        вместо `user.generate_jwt_token()`.

        Это возможно благодаря декоратору `@property`, указанному выше. `token` называется 
        "динамическим свойством".
        """
        return self._generate_jwt_token()

    def get_full_name(self):
        """
        Этот метод нужен Django, например, для работы с электронными письмами. 
        Чаще всего метод возвращает имя и фамилию пользователя. Но поскольку
        мы не храним настоящих имен пользователей, мы возвращаем вместо этого 
        их username.
        """
        return self.username

    def get_short_name(self):
        """
        Этот метод нужен Django, например, для работы с электронными письмами. 
        Чаще всего метод возвращает имя пользователя. Но поскольку
        мы не храним настоящих имен пользователей, мы возвращаем вместо этого 
        их username.
        """
        return self.username

    def _generate_jwt_token(self):
        """
        Генерирует JSON веб токен, который хранит ID данного пользователя, истекающий через 60 дней после создания.
        """
        dt = datetime.now() + timedelta(days=60)

        token = jwt.encode({
            'id': self.pk,
            'exp': int(dt.strftime('%s'))
        }, settings.SECRET_KEY, algorithm='HS256')

        return token.decode('utf-8')
```

Просмотрите приведенный выше фрагмент кода в течение нескольких минут, а затем сделайте следующее:

Если Вы хотите больше узнать о том как использовать нестандартную, пользовательскую аутентификацию в Django, Вам стоит изучить документацию. Материал, приведенный по ниже перечисленным ссылкам не является обязательным для изучения, но мы рекомендуем Вам ознакомиться с ним, если Вас заинтересовала эта тема:

* в разделе [models.CustomUser](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.CustomUser) указывается, что Django ожидает от нестандартной, пользовательской модели `User`.
* в моделях [models.AbstractBaseUser](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.AbstractBaseUser) и [models.PermissionsMixin](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.PermissionsMixin) уже реализованы некоторые из требований, указанных в предыдущей ссылке.
* в модели [models.BaseUserManager](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.BaseUserManager) представлены некотрые полезные инструменты, используя которые можно начать создавать свой класс `UserManager`.
* В [справочнике по полям модели](https://docs.djangoproject.com/en/1.10/ref/models/fields/) перечислены различные типы полей, поддерживаемые Django и параметры, которые можно передать в каждое поле (например, `db_index` и `unique`).

## Задаём параметр AUTH_USER_MODEL

По умолчанию Django предполагает, что для пользователей используется модель `django.contrib.auth.models.User`. Но мы хотим использовать нашу собственную, нестандартную модуль `User`. Поскольку мы создали класс `User`, теперь нам надо указать Django, что нужно использовать нашу модель `User` вместо той, которая используется по умолчанию.

> Настоятельно рекомендуем Вам прочитать главу документации [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model). Особенно разделы, отмеченные как "Предупреждения".

Если Вы уже осуществили миграцию базы данных перед тем как указать Django использовать нестандартную, пользовательскую модель `User`, Вам нужно удалить созданную базу данных и повторно осуществить миграции.

Задайте параметр `AUTH_USER_MODEL` в конце файла `conduit/settings.py`:

```python
# Сообщаем Django о созданной нами пользовательской модели `User`. Строка `authentication.User` сообщает Django, что нужно использовать модель `User` из модуля `authentication`. Этот модуль зарегистрирован выше, используя параметр `INSTALLED_APPS`.
AUTH_USER_MODEL = 'authentication.User'
```

## Создаём и запускаем миграции

По мере добавления новых моделей и изменении существующих, нам нужно будет обновлять базу данных, чтобы отразить эти изменения. Django использует миграции, чтобы сообщить базе данных, что что-то изменилось, и наша укажет базе данных о необходимости добавления новой таблицы для нашей нестандартной, пользовательской модели `User`.

> Замечание. Если Вы уже запускали команды `python manage.py makemigrations` или `python manage.py migrate`, Вам нужно удалить базу данных прежде чем продолжить. Если Вы используете SQLite в качестве базы данных, то просто удалите файл `db.sqlite3` из корневого каталога Вашего проекта. Django выдаст ошибку, если Вы измените параметр `AUTH_USER_MODEL` после создания базы данных, поэтому лучше всего удалить старую базу и создать новую.

Теперь можно создавать и применять миграции. После этого мы можем создать нашего первого пользователя.

Чтобы создать миграции, выполните в консоли следующую команду:

```
python manage.py makemigrations
```
Эта команда создаст миграции по умолчанию для нашего нового Django проекта. Но она не создаст миграции для новых приложений внутри нашего проекта. В первый раз, когда мы хотим создать миграции для нашего нового приложения, мы должны явно указать это.

Чтобы создать набор миграций для приложения `authentication`, запустите следующую команду:

```
python manage.py makemigrations authentication
```

Она создаст первоначальную миграцию для приложения `authentication`. В дальнейшем, когда Вы захотите создать миграцию для этого приложения, Вам достаточно будет запустить `python manage.py makemigrations`.

Теперь мы можем применить созданные миграции, выполнив следующую команду в консоли:

```
python manage.py migrate
```

В отличие от команды `makemigrations`, Вам никогда не нужно указывать приложение, для которого нужно применить миграции, при запуске команды `migrate`.

## Наш первый пользователь

## Регистрируем новых пользователей

### RegistrationSerializer 

### RegistrationAPIView

## Регистрируем пользоваталей с помощью Postman

## Отображаем объекты User

## Реализация входа пользователей в систему

## LoginSerializer

## LoginAPIView

## Осуществляем вход пользователя в систему с помощью Postman

## Изменяем параметры EXCEPTION_HANDLER и NON_FIELD_ERRORS_KEY

## Обновляем UserJSONRenderer

## Получаем и обновляем информацию о пользователях

## UserSerializer

## UserRetrieveUpdateAPIView

## Аутентифицируем пользователей

## Сообщаем DRF о нашем бекэнде для аутентификации

## Осуществляем получение и обновление информации о пользователях с помощью Postman

## Переходим к более интересным темам

