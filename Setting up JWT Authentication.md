# Настраиваем аутентификацию пользователей с помощью JWT

В состав Django входит система аутентификации на базе сессий, которая работает "из коробки". В неё входят все модели, представления и шаблоны, необходимые для входа пользователей в систему и создания новых учётных записей. Но существует проблема: эта аутентификация Django работает только при использовании стандартного HTML цикла - запрос/ответ.

Что мы подразумеваем под "стандартным HTML циклом запрос/ответ"? Обычно, когда пользователь хочет осуществить какое-либо действие (например, создать новую учётную запись), он заполняет форму в своём веб браузере. Когда он нажимает кнопку "Отправить", браузер делает запрос (который включает данные, введенные пользователем в регистрацию форму) к серверу, сервер обрабатывает этот запрос и отвечает HTML кодом или перенаправляет браузер на новую страницу. Это то, что мы имеем ввиду, когда говорим о "полном обновлении страницы".

Почему важно знать, что встроенная аутентификация Django работает только со стандартным HTML циклом запрос/ответ? Потому что клиентское приложение, для которого мы создаём это API, не использует этот цикл. Вместо этого, клиентское приложение ожидает, что сервер вернет JSON вместо HTML. Возвращая JSON, мы позволяем клиентскому приложению, а не серверу, решать, что делать дальше. При использовании JSON цикла запрос/ответ, сервер принимает данные, обрабатывает их и возвращает ответ (как и в случае HTML цикла запрос/ответ), но ответ больше не управляет поведением браузера. Он просто сообщает нам результат выполнения запроса.

К счастью, команда, разрабатывающая Django, поняла, что тенденция веб разработки двигается в этом направлении. Они также учли, что некоторые проекты могут не захотеть использовать встроенные модели, представления и шаблоны. Вместо этого они могут захотеть использовать свои версии. Чтобы все усилия потраченные на разработку встроенной систему аутентификации Django не были потрачены впустую, они решили позволять использовать наиболее важные её части, при этом оставляя возможность настраивать конечный результат.

Мы более подробно рассмотрим этот вопрос позднее в этом разделе. Пока что, Вам необходимо знать, что:

1. Мы создадим свою собственную модель `User` вместо той, что используется в Django по умолчанию.
2. Нам нужно будет создать свои собственные представления, позволяющие возвращать JSON вместо HTML.
3. Поскольку мы не будем использовать HTML, нам не будут нужны стандартные Django шаблоны для входа в систему и регистрации.

Возможно Вы задаётесь вопросом - "Неужели придется писать систему аутентификации с нуля"? Для ответа не него вспомните то, о чём мы говорили раньше - Django позволяет использовать основные части аутентификации без использования стандартной системы аутентификации.

> Прочитайте раздел [Использование системы аутентификации Django](https://docs.djangoproject.com/es/1.11/topics/auth/default/) из документации Django, чтобы узнать больше о том как работает стандартная аутентификация Django.
> Прочитайте раздел [Модификация аутентификации в Django](https://docs.djangoproject.com/es/1.9/topics/auth/customizing/), чтобы лучше понять, что будет происходить в оставшейся части этой главы. Мы будем использовать информацию из этого раздела позднее.

## Аутентификациия с использованием сессий

По умолчанию Django использует сессии для аутентификации. Прежде чем мы продолжим поговорим о том, что это означает, почему это важно, что такое аутентификация с использованием токенов и JSON веб токены (сокращенно JWT), и какой способ аутентификации мы будем использовать в этом курсе.

В Django сессии хранятся в cookies. Эти сессии, а также некоторое встроенное связующее программное обеспечение и объекты запроса гарантируют, что у каждого запроса существует связанный с ним пользователь. К нему можно получить доступ через `request.user`. Когда пользователь вошёл в систему, `request.user` - это экземпляр класса `User`. Когда пользователь выходит из системы, `request.user` - это экземпляр класса `AnonymousUser`. Не зависимо от того аутентфиицирован пользователь или нет, `request.user` всегда будет существовать.

В чём отличие между экземплярами этих объектов? Упрощая скажем, что в любой момент, когда Вы хотите узнать аутентифицирован ли текущий пользователь, Вы можете использовать метод `request.user.is_authenticated()`, который вернет `True`, если пользователь аутентифицирован и `False`, если нет. Если `request.user` - это экземпляр `AnonymousUser`, то `request.user.is_authenticated()` всегда вернет `False`. Это позволяет разработчику (т. е. Вам!) вместо выражения `if request.user is not None and request.user.is_authenticated():` использовать `if request.user.is_authenticated():`. Уменьшение количества вводимых с клавиатуры символов не может не радовать в этом случае!

В нашем случае клиентское и серверное приложение будут запущены на разных серверах. Серверное приложение будет доступно по адресу `http://localhost:3000/`, а клиентское - по `http://localhost:5000/`. В этом случае браузер считает, что приложения запущены на разных доменах как если бы сервер был бы запущен на `http://www.server.com`, а клиент - на `http://www.client.com`. Мы не позволим внешним доменам получать доступ к нашим cookies, поэтому нам нужно найти другое, альтернативное решение, не использующее сессии.

Если Вам интересно почему мы не разрешаем доступ к нашим cookies, ознакомтесь со статьями, посвященными совместному использованию ресурсов между разными источникам (Cross-Origin Resource Sharing (CORS)) и межсайтовой подделкой запросов (Cross-Site Request Forgery (CSRF)), по приведенным ниже ссылкам. Если Вам не терпиться начать писать код, просто перейдите к следующему разделу.

> Чтобы узнать больше о Cross-Origin Resource Sharing (CORS), прочитайте эту статью [HTTP управление доступом (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
> Чтобы узнать больше о том как Django защищается от CSRF атак, прочитайте эту статью [Защита от межсайтовой подделки запроса](https://docs.djangoproject.com/ja/1.11/ref/csrf/).

## Аутентификация с использованием токенов

Наиболее распространенной альтернативой аутентификации с использованием сессий является аутентификация с использованием токенов, и мы будем использовать особую разновидность аутентификации с использованием токенов для защиты нашего приложения.

При использовании аутентификации с использованием токенов сервер выдаёт клиенту токен при успешном входе в систему. Этот токен уникален для каждого вошедшего в систему пользователя и хранится в базе данных вместе с ID пользователя. Подразумевается, что клиент будет посылать токен при последующих запросах, чтобы сервер мог идентифицировать пользователя. Сервер осуществляет идентификацию путем поиска в таблице базе данных, содержащей все созданные токены. Если найден соответствующий токен, сервер проверяет не устарел ли он. Если посланный токен не найден, то пользователь считается не аутентифицированным.

Поскольку токены хранятся в базе данных, а не в куки, аутентификация с использованием токенов соответствует нашим требованиям.

### Проверяем токены

Всегда существует возможность хранить не только ID пользователя в токене. Мы также можем хранить в нём такую информацию, как, например, дату, когда истекает токен. В этом учебном пособии мы будем проверять, то эта дата ещё не настала. В противном случае, считается, что токен устарел и не действителен. Поэтому мы удаляем его из базы данных и просим пользователя снова войти в систему.

## JSON веб токены

JSON веб токен (сокращенно JWT) является открытым стандартом ([RFC 7519](https://tools.ietf.org/html/rfc7519)), который определяет компактный и автономный способ безопасной передачи информации между двумя взаимодействующими сторонами. Вы можете считать JWT улучшенной версией токенов для аутентификации.

Помните, что выше я говорил об использовании особой разновидности аутентификации с использованием токенов? Я имел ввиду JWT.

> Чтобы узнать больше о JWT и о том как они работают, прочитайте эту статью [Введение в JSON веб токены](https://tools.ietf.org/html/rfc7519).

## Почему JSON веб токены лучше, чем обычные токены

Существует несколько преимуществ при использовании JWT вместо обычных токенов:
1) JWT - это открытый стандарт. Это означает, что все реализации JWT должны быть достаточно однотипными, что является преимуществом при работе с разными языками и технологиями. Обычные токены не имеют жёсткой привязки к стандартам, что позволяет разработчику решать как лучше всего реализовать токены.
2) JWT могут содержать всю информацию о пользователе, что довольно удобно для клиента.
3) О сложностях, связанных с реализацией алгоритмов, не стоит беспокоиться, поскольку уже существуют готовые бибилиотеки. Использовать самописную систему аутентификации довольно небезопасно, поэтому здесь мы полагаемся "на проверенные в бою" библиотеки, которым можно доверять.

## Создаём модель User (Пользователь)

Не пора ли начать писать код?

В файле `conduit/apps/authentication/models.py` хранятся модели, которые мы будем использовать для аутентификации. Если Вы уже склонировали репозиторий, то наверное заметили, что каталог `conduit/apps/authentication/` уже существует. Но в нём нет файла `models.py`. Создайте его.

> В этом курсе мы специально довольно кратко рассматриваем каждый фрагмент кода. Мы уверены, что используя комментарии в коде и ресурсы, на которые мы даём ссылки, Вы сможете найти всю необходумую Вам информацию.

Нам нужно будет добавить следующие импорты для создания классов `User` и `UserManager`, поэтому добавьте следующий код в начало файла:

```python
import jwt

from datetime import datetime, timedelta

from django.conf import settings
from django.contrib.auth.models import (
    AbstractBaseUser, BaseUserManager, PermissionsMixin
)
from django.db import models
```
Настраивая аутентификацию в Django необходимо указать, что Вы используете свой, пользовательский класс `Manager` с двумя методами: `create_user` и `create_superuser`. Чтобы узнать как настроить аутентификацию в Django, прочитайте раздел [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model).

Для начала создайте класс `UserManager`.

Введите код для класса `UserManager` в файл `conduit/apps/authentication/models.py` и обратите внимание на комментарии:

> Прочитайте раздел [Менеджеры](https://docs.djangoproject.com/en/1.10/topics/db/managers/), чтобы узнать что делает класс `Manager`.

```python
class UserManager(BaseUserManager):
    """
    Django требует, чтобы при создании нестандартной, пользовательской модели 
    пользователя использовался свой собственный класс Manager. Наследуясь от 
    `BaseUserManager`, мы заимствуем большую часть кода, которая используется Django
    при создании модели `User`.
    
    Все что нам остаётся сделать - это переопределить функцию `create_user`, которую
    мы будем использовать для создания объектов `User`.        
    """

    def create_user(self, username, email, password=None):
        """Метод создаёт и возвращает модель `User` 
        с электронной почтой, именем пользователя и паролем."""
        if username is None:
            raise TypeError('Users must have a username.')

        if email is None:
            raise TypeError('Users must have an email address.')

        user = self.model(username=username, email=self.normalize_email(email))
        user.set_password(password)
        user.save()

        return user

    def create_superuser(self, username, email, password):
        """Метод создаёт и возвращает модель `User` с правами 
        суперпользователя (админа)."""
        if password is None:
            raise TypeError('Superusers must have a password.')

        user = self.create_user(username, email, password)
        user.is_superuser = True
        user.is_staff = True
        user.save()

        return user
```

Теперь, когда мы создали класс `UserMenager`, мы можем создать модель `User`. Добавьте модель `User` в конец файла `conduit/apps/authentication/models.py`.

```python
class User(AbstractBaseUser, PermissionsMixin):
    # У каждого `User` должен быть уникальный человеко-понятный идентификатор,
    # который мы можем использовать для представления `User` в UI. Мы хотим
    # проиндексировать этот столбец в базе данных для ускорения поиска.    
    username = models.CharField(db_index=True, max_length=255, unique=True)

    # Нам также нужно каким-то образом связываться с пользователем
    # и способ идентификации пользователя при входе в систему. Поскольку нам в
    # любом случае необходим адрес электронной почты для связи с пользователем, 
    # мы будем также использовать email для входа в систему, поскольку он 
    # наиболее часто используется в качестве логина на момент написания учебного 
    # пособия.    
    email = models.EmailField(db_index=True, unique=True)

    # Когда пользователь больше не захочет использовать нашу платформу,     
    # он может захотеть удалить свою учетную запись. Для нас это будет проблемой, 
    # поскольку собранные о пользователе данные ценны для нас и мы не хотим удалять их. 
    # Мы просто предложим пользователям отключить их учетную запись вместо её удаления.
    # Таким образом, они больше не будут отображаться на сайте, но мы сможем продолжать
    # анализировать собранные данные.    
    is_active = models.BooleanField(default=True)

    # Флаг `is_staff` используется Django, чтобы определить кто может, 
    # а кто - нет входить в систему администрирования Django. Для большинства пользователей
    # значение этого флага всегда будет равно false.
    is_staff = models.BooleanField(default=False)

    # Временная метка, показывающая когда был создан этот объект.
    created_at = models.DateTimeField(auto_now_add=True)

    # Временная метка, показывающая, когда в последний раз обновлялся этот объект.
    updated_at = models.DateTimeField(auto_now=True)

    # При использовании нестандартной, пользовательской модели пользователя необходимо
    # определить дополнительные поля, требуемые Django.

    # Свойство `USERNAME_FIELD` указывает какое поле будет использоваться для входа в систему.
    # Здесь мы хотим использовать поле email.
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    # Сообщаем Django, что для работы с объектами этого типа нужно использовать 
    # определенный выше класс UserManager.
    objects = UserManager()

    def __str__(self):
        """
        Метод возвращает строковое предствление текущего `User`.

        Эта строка используется при выводе модели `User` в консоли.        
        """
        return self.email

    @property
    def token(self):
        """
        Метод позволяет нам получить токен пользователя, вызывая `user.token` 
        вместо `user.generate_jwt_token()`.

        Это возможно благодаря декоратору `@property`, указанному выше. `token` называется 
        "динамическим свойством".
        """
        return self._generate_jwt_token()

    def get_full_name(self):
        """
        Этот метод нужен Django, например, для работы с электронными письмами. 
        Чаще всего метод возвращает имя и фамилию пользователя. Но поскольку
        мы не храним настоящих имен пользователей, мы возвращаем вместо этого 
        их username.
        """
        return self.username

    def get_short_name(self):
        """
        Этот метод нужен Django, например, для работы с электронными письмами. 
        Чаще всего метод возвращает имя пользователя. Но поскольку
        мы не храним настоящих имен пользователей, мы возвращаем вместо этого 
        их username.
        """
        return self.username

    def _generate_jwt_token(self):
        """
        Генерирует JSON веб токен, который хранит ID данного пользователя, истекающий через 60 дней после создания.
        """
        dt = datetime.now() + timedelta(days=60)

        token = jwt.encode({
            'id': self.pk,
            'exp': int(dt.strftime('%s'))
        }, settings.SECRET_KEY, algorithm='HS256')

        return token.decode('utf-8')
```

Просмотрите приведенный выше фрагмент кода в течение нескольких минут, а затем сделайте следующее:

Если Вы хотите больше узнать о том как использовать нестандартную, пользовательскую аутентификацию в Django, Вам стоит изучить документацию. Материал, приведенный по ниже перечисленным ссылкам не является обязательным для изучения, но мы рекомендуем Вам ознакомиться с ним, если Вас заинтересовала эта тема:

* в разделе [models.CustomUser](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.CustomUser) указывается, что Django ожидает от нестандартной, пользовательской модели `User`.
* в моделях [models.AbstractBaseUser](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.AbstractBaseUser) и [models.PermissionsMixin](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.PermissionsMixin) уже реализованы некоторые из требований, указанных в предыдущей ссылке.
* в модели [models.BaseUserManager](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#django.contrib.auth.models.BaseUserManager) представлены некотрые полезные инструменты, используя которые можно начать создавать свой класс `UserManager`.
* В [справочнике по полям модели](https://docs.djangoproject.com/en/1.10/ref/models/fields/) перечислены различные типы полей, поддерживаемые Django и параметры, которые можно передать в каждое поле (например, `db_index` и `unique`).

## Задаём параметр AUTH_USER_MODEL

По умолчанию Django предполагает, что для пользователей используется модель `django.contrib.auth.models.User`. Но мы хотим использовать нашу собственную, нестандартную модуль `User`. Поскольку мы создали класс `User`, теперь нам надо указать Django, что нужно использовать нашу модель `User` вместо той, которая используется по умолчанию.

> Настоятельно рекомендуем Вам прочитать главу документации [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model). Особенно разделы, отмеченные как "Предупреждения".

Если Вы уже осуществили миграцию базы данных перед тем как указать Django использовать нестандартную, пользовательскую модель `User`, Вам нужно удалить созданную базу данных и повторно осуществить миграции.

Задайте параметр `AUTH_USER_MODEL` в конце файла `conduit/settings.py`:

```python
# Сообщаем Django о созданной нами пользовательской модели `User`. Строка `authentication.User` сообщает Django, что нужно использовать модель `User` из модуля `authentication`. Этот модуль зарегистрирован выше, используя параметр `INSTALLED_APPS`.
AUTH_USER_MODEL = 'authentication.User'
```

## Создаём и запускаем миграции

По мере добавления новых моделей и изменении существующих, нам нужно будет обновлять базу данных, чтобы отразить эти изменения. Django использует миграции, чтобы сообщить базе данных, что что-то изменилось, и наша укажет базе данных о необходимости добавления новой таблицы для нашей нестандартной, пользовательской модели `User`.

> Замечание. Если Вы уже запускали команды `python manage.py makemigrations` или `python manage.py migrate`, Вам нужно удалить базу данных прежде чем продолжить. Если Вы используете SQLite в качестве базы данных, то просто удалите файл `db.sqlite3` из корневого каталога Вашего проекта. Django выдаст ошибку, если Вы измените параметр `AUTH_USER_MODEL` после создания базы данных, поэтому лучше всего удалить старую базу и создать новую.

Теперь можно создавать и применять миграции. После этого мы можем создать нашего первого пользователя.

Чтобы создать миграции, выполните в консоли следующую команду:

```
python manage.py makemigrations
```
Эта команда создаст миграции по умолчанию для нашего нового Django проекта. Но она не создаст миграции для новых приложений внутри нашего проекта. В первый раз, когда мы хотим создать миграции для нашего нового приложения, мы должны явно указать это.

Чтобы создать набор миграций для приложения `authentication`, запустите следующую команду:

```
python manage.py makemigrations authentication
```

Она создаст первоначальную миграцию для приложения `authentication`. В дальнейшем, когда Вы захотите создать миграцию для этого приложения, Вам достаточно будет запустить `python manage.py makemigrations`.

Теперь мы можем применить созданные миграции, выполнив следующую команду в консоли:

```
python manage.py migrate
```

В отличие от команды `makemigrations`, Вам никогда не нужно указывать приложение, для которого нужно применить миграции, при запуске команды `migrate`.

## Наш первый пользователь

Мы создали свою модель `User` и настроили и запустили базу данных. Следующий шаг - это создание нашего первого объекта `User`. Мы дадим этому пользователю права суперпользователя, чтобы с его помощью тестировать наш сайт.

Создайте вашего первого пользователя, выполнив в консоли следующую команду:

```
python manage.py createsuperuser
```

Django задаст Вам несколько вопросов - нужно будет ввести адрес электронной почты, имя пользователя и пароль. После этого будет создан новый пользователь. Поздравляем!

Чтобы проверить то, что пользователь действительно создался, давайте откроем оболочку Django из командной строки:

```
python manage.py shell_plus
```

Если Вы уже использовали Django, то Вы должны быть знакомы с командой `shell`, но не с `shell_plus`. Команда `shell_plus` доступна благодаря библиотеке `django-extensions`, которая была включена в склонированный Вами проект в начале этого учебного пособия. Библиотеку стоит использовать, поскольку она позволяет автоматически импортировать модели для каждого приложения в настройку `INSTALLED_APPS`. Её также можно настроить для автоматического импортирования других вспомогательных средств.

Как только откроется оболочка, выполните следующие команды:

> *Замечание*. Вам нужно вводить только команды из строк, перед которыми стоит символ приглашения командной строки `>>>`. Строки без `>>>` - это результат выполнения команды, выводимый в консоль.

```
>>> user = User.objects.first()
>>> user.username
‘james'
>>> user.token
'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0Njk0MDY2OTksImlkIjoxfQ.qSnwWVD4PJKhKxgLxY0H5mkTE51QnMWv_kqNJVau1go'
```

Если Вы всё сделали правильно, то должны увидеть результат аналогичный тому, который показан в данном фрагменте.

## Регистрируем новых пользователей

На данный момент пользователь ничего не может делать. Наша следующая задача - создать конечную точку для регистрации новых пользователей.

### RegistrationSerializer 

Начнём с создания файла `conduit/apps/authentication/serializers.py`, введя в него следующий код:

```python
from rest_framework import serializers

from .models import User


class RegistrationSerializer(serializers.ModelSerializer):
    ""Сериализует запросы на регистрацию и создаёт нового пользователя."""

    # Указываем, что пароль должен быть не менее 8 символов, 
    # не более 128 символов и не может быть прочитан клиентом    
    password = serializers.CharField(
        max_length=128,
        min_length=8,
        write_only=True
    )

    # У клиента не должно быть возможности посылать токен при запросе на регистрацию.
    # Для этого мы передаём в `token` параметр read-only.
    token = serializers.CharField(max_length=255, read_only=True)

    class Meta:
        model = User
        # Здесь перечисляются все поля, которые могут быть включаны в запрос или ответ
        # с учетом явно указанных выше полей.         
        fields = ['email', 'username', 'password', 'token']

    def create(self, validated_data):
        # Используем метод `create_user`? написанный ранее для создания нового пользователя.
        return User.objects.create_user(**validated_data)
```

Просмотрите этот код, уделяя особое внимание комментариям в нём, прежде чем продолжить чтение данного учебного пособия.

В вышеприведенном коде мы создали класс `RegistrationSerializer`, который наследуется от `serializers.ModelSerializer`. `serializers.ModelSerializer` - это абстракция `serializers.Serializer`, которую Вы возможно помните, если читали учебное пособие по Django REST фреймворку (DRF). `ModelSerializer` реализует некоторый функционал, необходимый для сериализации Django моделей вместо нас.

Также отметим, что сериализатор позволяет Вам определить два метода: `create` и `update`. В вышеприведенном примере мы создали наш собственный метод `create`, используя `User.objects.create_user`, но не определили метод `update`. В этом случае DRF будет использовать свой собственный стандартный метод `update` для обновления информации о пользователе.

### RegistrationAPIView

Теперь мы можем сериализовать запросы и ответы для регистрации пользователя. Затем мы создадим представление, которое будет использоваться как конечная точка, так что клиент должен будет перейти по URL, чтобы создать нового пользователя.

Создайте `conduit/apps/authentication/views.py` и введите следующий код:

```python
from rest_framework import status
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView

from .serializers import RegistrationSerializer


class RegistrationAPIView(APIView):
    # Позволяем любому пользователю (аутентифицированному или нет) переходить на эту конечную точку.
    permission_classes = (AllowAny,)
    serializer_class = RegistrationSerializer

    def post(self, request):
        user = request.data.get('user', {})

        # Код, используемый ниже для сериализатора создания, проверки и сохранения пользователя 
        # является стандартным и Вы будете их часто встречать на протяжении этого курса и позднее работая самостоятельно. 
        # Ознакомтесь с ними.
        serializer = self.serializer_class(data=user)
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

Давайте рассмотрим некоторые новые моменты в этом фрагменте:

1. Свойство `permission_classes` позволяет определить кто можем использовать эту конечную точку. Мы можем разрешить доступ только аутентифицированным пользователям или пользователям с правами администратора. Мы также можем разрешать доступ только аутентфиицированным пользователям или любому пользователю, основываясь на том является ли эта конечная точка "безопасной" - то есть конечная точка запрашивается с помощью `GET`, `HEAD` или `OPTIONS` запроса. Для изучения этого курса Вам нужно знать только о `GET` запросах.  Мы поговорим подробнее о `permissions_classes` позже.
2. Код, который Вы видите внутри `post` метода для сериализатора создания, проверки и сохранения пользователя является стандартным, при использовании DRF. Ознакомтесь с этим кодом, поскольку Вы будете часто его использовать.

> Прочитайте о [правах доступа](http://www.django-rest-framework.org/api-guide/permissions/) DRF.

Создайте файл `conduit/apps/authentication/urls.py` и добавьте в него следующий код:

```python
from django.conf.urls import url

from .views import RegistrationAPIView

urlpatterns = [
    url(r'^users/?$', RegistrationAPIView.as_view()),
]
```

Если Вы уже работали с другим фреймворком, таким как Rails, Вам может показаться странным, что первый аргумент, который мы передаём методу `url` - это регулярное выражение. К этому необходимо привыкнуть, но привыкнув, Вы увидите, что это мощный инструмент. Например, вышеприведенный маршрут будет соответствовать как `/users`, так и `/users/`. Это связано с тем, что в Django принято заканчивать маршруты обратным слешом. К сожалению, это противоречит нашим требованиям, согласоно которым не желательно использовать обратные слеши в конце путей. К счастью команда разработчиков Django приходит к нам на помощь. Другое отличие между Django и Rails заключается в том, что в Rails обычно все Ваши пути находятся в одном файле. Хотя можно поступить также в Django считается хорошей практикой разделять пути по отдельным файлам из-за причин, связанных с организацией проекта. Вот что мы сделали здесь. Теперь давайте добавим вышеприведенный файл в наш глобальный файл URL. Откройте `conduit/urls.py` и Вы увидите следующую строку в начале файла:

```python
from django.conf.urls import url
```

Первое, что мы сделаем, это испортируем метод `include` из `django.conf.urls`:

```python
-from django.conf.urls import url
+from django.conf.urls import include, url
```

Метод `include` позволяет добавить другой файл `urls.py` без необходимости выполнения такой работы как импортирование и повторное регистрирование путей в этом файле.

Ниже Вы увидите:

```python
urlpatterns = [
    url(r'^admin/', admin.site.urls),
]
```

ОБновим этот фрагмент, добавив наш новый файл `urls.py `:

```python
urlpatterns = [
    url(r'^admin/', admin.site.urls),
+
+    url(r'^api/', include('conduit.apps.authentication.urls', namespace='authentication')),
]
```

## Регистрируем пользователей с помощью Postman

Теперь когда мы создали модель `User` и добавили конечную точку для регистрации новых пользователей, мы быстро проверим её работоспособность, чтобы убедиться, что всё работает правильно. Для этого мы будем использовать инструмент Postman c заранее созданным набором конечных точек.

Если Вы никогда раньше не использовали Postman, ознакомьтесь со учебным пособием [Тестируем Conduit приложение, используя Postman](https://thinkster.io/tutorials/testing-backend-apis-with-postman).

Откройте Postman и используйте "Register" запрос внутри каталога "Auth", чтобы создать нового пользователя.

Превосходно! Впервые мы достигли какого-то реального прогресса!

Тем не менее кое-что нам нужно исправить. Заметьте, что ответ на запрос "Register" просто выдаёт всю информацию о пользователе. Наш клиент ожидает, что эта информация будет храниться в отдельном пространтсве имен `user`. Для этого мы создадим свой собственный пользовательский [DRF формирователь ответа от сервера](http://www.django-rest-framework.org/api-guide/renderers/).

## Отображаем объекты User

Создайте файл с названием `conduit/apps/authentication/renderers.py` со следующий содержимым:

```python
import json

from rest_framework.renderers import JSONRenderer


class UserJSONRenderer(JSONRenderer):
    charset = 'utf-8'

    def render(self, data, media_type=None, renderer_context=None):
        # Если был передан ключ `token` в запросе, то он будет байтовым объектом.
        # Байтовые объекты плохо сериализуются, поэтому нам надо его декодировать
        # прежде чем выдавать объект User.
        token = data.get('token', None)

        if token is not None and isinstance(token, bytes):
            # Как было сказано выше, мы декодируем `token` только в том случае,
            # если он является байтовым объектом.
            data['token'] = token.decode('utf-8')

        # Наконец мы можем выдать наши данные в пространстве имен "user".
        return json.dumps({
            'user': data
        })
```
В этом фрагменте кода нет ничего нового или интересного, поэтому прочитайте комментарии приведенные там и можете двигаться дальше.

Теперь откройте `conduit/apps/authentication/views.py` и импортируйте `UserJSONRenderer`, добавив следующую строку в начало Вашего файла:

```python
from .renderers import UserJSONRenderer
```

Вам также будет необходимо задать свойство `renderer_classes` класса `RegistrationAPIView` следующим образом:

```python
class RegistrationAPIView(APIView):
    permission_classes = (AllowAny,)
+    renderer_classes = (UserJSONRenderer,)
    serializer_class = RegistrationSerializer

    # … Остальная часть файла
```

С помощью `UserJSONRenderer` теперь используя запрос "Register" в Postman создайте новго пользователя. Заметьте, что в этот раз ответ находится внутри пространства имен "user".

## Реализация входа пользователей в систему

Поскольку пользователи теперь могут регистрироваться в приложении Conduit, нам необходим способ с помощью которого они могли бы войти в систему. В этом разделе мы добавим сериализатор и представление, необходимые для того, чтобы пользователи могли войти в систему. Мы также рассмотрим вопрос, связанный с тем как наш API должен обрабатывать ошибки.

## LoginSerializer

## LoginAPIView

## Осуществляем вход пользователя в систему с помощью Postman

## Изменяем параметры EXCEPTION_HANDLER и NON_FIELD_ERRORS_KEY

## Обновляем UserJSONRenderer

## Получаем и обновляем информацию о пользователях

## UserSerializer

## UserRetrieveUpdateAPIView

## Аутентифицируем пользователей

## Сообщаем DRF о нашем бекэнде для аутентификации

## Осуществляем получение и обновление информации о пользователях с помощью Postman

## Переходим к более интересным темам

