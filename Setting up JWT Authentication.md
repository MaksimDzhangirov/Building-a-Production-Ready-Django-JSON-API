# Настраиваем аутентификацию пользователей с помощью JWT

В состав Django входит система аутентификации на базе сессий, которая работает "из коробки". В неё входят все модели, представления и шаблоны, необходимые для входа пользователей в систему и создания новых учётных записей. Но существует проблема: эта аутентификация Django работает только при использовании стандартного HTML цикла - запрос/ответ.

Что мы подразумеваем под "стандартным HTML циклом запрос/ответ"? Обычно, когда пользователь хочет осуществить какое-либо действие (например, создать новую учётную запись), он заполняет форму в своём веб браузере. Когда он нажимает кнопку "Отправить", браузер делает запрос (который включает данные, введенные пользователем в регистрацию форму) к серверу, сервер обрабатывает этот запрос и отвечает HTML кодом или перенаправляет браузер на новую страницу. Это то, что мы имеем ввиду, когда говорим о "полном обновлении страницы".

Почему важно знать, что встроенная аутентификация Django работает только со стандартным HTML циклом запрос/ответ? Потому что клиентское приложение, для которого мы создаём это API, не использует этот цикл. Вместо этого, клиентское приложение ожидает, что сервер вернет JSON вместо HTML. Возвращая JSON, мы позволяем клиентскому приложению, а не серверу, решать, что делать дальше. При использовании JSON цикла запрос/ответ, сервер принимает данные, обрабатывает их и возвращает ответ (как и в случае HTML цикла запрос/ответ), но ответ больше не управляет поведением браузера. Он просто сообщает нам результат выполнения запроса.

К счастью, команда, разрабатывающая Django, поняла, что тенденция веб разработки двигается в этом направлении. Они также учли, что некоторые проекты могут не захотеть использовать встроенные модели, представления и шаблоны. Вместо этого они могут захотеть использовать свои версии. Чтобы все усилия потраченные на разработку встроенной систему аутентификации Django не были потрачены впустую, они решили позволять использовать наиболее важные её части, при этом оставляя возможность настраивать конечный результат.

Мы более подробно рассмотрим этот вопрос позднее в этом разделе. Пока что, Вам необходимо знать, что:

1. Мы создадим свою собственную модель `User` вместо той, что используется в Django по умолчанию.
2. Нам нужно будет создать свои собственные представления, позволяющие возвращать JSON вместо HTML.
3. Поскольку мы не будем использовать HTML, нам не будут нужны стандартные Django шаблоны для входа в систему и регистрации.

Возможно Вы задаётесь вопросом - "Неужели придется писать систему аутентификации с нуля"? Для ответа не него вспомните то, о чём мы говорили раньше - Django позволяет использовать основные части аутентификации без использования стандартной системы аутентификации.

> Прочитайте раздел [Использование системы аутентификации Django](https://docs.djangoproject.com/es/1.11/topics/auth/default/) из документации Django, чтобы узнать больше о том как работает стандартная аутентификация Django.
> Прочитайте раздел [Модификация аутентификации в Django](https://docs.djangoproject.com/es/1.9/topics/auth/customizing/), чтобы лучше понять, что будет происходить в оставшейся части этой главы. Мы будем использовать информацию из этого раздела позднее.

## Аутентификациия с использованием сессий

По умолчанию Django использует сессии для аутентификации. Прежде чем мы продолжим поговорим о том, что это означает, почему это важно, что такое аутентификация с использованием токенов и JSON веб токены (сокращенно JWT), и какой способ аутентификации мы будем использовать в этом курсе.

В Django сессии хранятся в cookies. Эти сессии, а также некоторое встроенное связующее программное обеспечение и объекты запроса гарантируют, что у каждого запроса существует связанный с ним пользователь. К нему можно получить доступ через `request.user`. Когда пользователь вошёл в систему, `request.user` - это экземпляр класса `User`. Когда пользователь выходит из системы, `request.user` - это экземпляр класса `AnonymousUser`. Не зависимо от того аутентфиицирован пользователь или нет, `request.user` всегда будет существовать.

В чём отличие между экземплярами этих объектов? Упрощая скажем, что в любой момент, когда Вы хотите узнать аутентифицирован ли текущий пользователь, Вы можете использовать метод `request.user.is_authenticated()`, который вернет `True`, если пользователь аутентифицирован и `False`, если нет. Если `request.user` - это экземпляр `AnonymousUser`, то `request.user.is_authenticated()` всегда вернет `False`. Это позволяет разработчику (т. е. Вам!) вместо выражения `if request.user is not None and request.user.is_authenticated():` использовать `if request.user.is_authenticated():`. Уменьшение количества вводимых с клавиатуры символов не может не радовать в этом случае!

В нашем случае клиентское и серверное приложение будут запущены на разных серверах. Серверное приложение будет доступно по адресу `http://localhost:3000/`, а клиентское - по `http://localhost:5000/`. В этом случае браузер считает, что приложения запущены на разных доменах как если бы сервер был бы запущен на `http://www.server.com`, а клиент - на `http://www.client.com`. Мы не позволим внешним доменам получать доступ к нашим cookies, поэтому нам нужно найти другое, альтернативное решение, не использующее сессии.

Если Вам интересно почему мы не разрешаем доступ к нашим cookies, ознакомтесь со статьями, посвященными совместному использованию ресурсов между разными источникам (Cross-Origin Resource Sharing (CORS)) и межсайтовой подделкой запросов (Cross-Site Request Forgery (CSRF)), по приведенным ниже ссылкам. Если Вам не терпиться начать писать код, просто перейдите к следующему разделу.

> Чтобы узнать больше о Cross-Origin Resource Sharing (CORS), прочитайте эту статью [HTTP управление доступом (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
> Чтобы узнать больше о том как Django защищается от CSRF атак, прочитайте эту статью [Защита от межсайтовой подделки запроса](https://docs.djangoproject.com/ja/1.11/ref/csrf/).

## Аутентификация с использованием токенов

Наиболее распространенной альтернативой аутентификации с использованием сессий является аутентификация с использованием токенов, и мы будем использовать особую разновидность аутентификации с использованием токенов для защиты нашего приложения.

При использовании аутентификации с использованием токенов сервер выдаёт клиенту токен при успешном входе в систему. Этот токен уникален для каждого вошедшего в систему пользователя и хранится в базе данных вместе с ID пользователя. Подразумевается, что клиент будет посылать токен при последующих запросах, чтобы сервер мог идентифицировать пользователя. Сервер осуществляет идентификацию путем поиска в таблице базе данных, содержащей все созданные токены. Если найден соответствующий токен, сервер проверяет не устарел ли он. Если посланный токен не найден, то пользователь считается не аутентифицированным.

Поскольку токены хранятся в базе данных, а не в куки, аутентификация с использованием токенов соответствует нашим требованиям.

### Проверяем токены

Всегда существует возможность хранить не только ID пользователя в токене. Мы также можем хранить в нём такую информацию, как, например, дату, когда истекает токен. В этом учебном пособии мы будем проверять, то эта дата ещё не настала. В противном случае, считается, что токен устарел и не действителен. Поэтому мы удаляем его из базы данных и просим пользователя снова войти в систему.

## JSON веб токены

JSON веб токен (сокращенно JWT) является открытым стандартом ([RFC 7519](https://tools.ietf.org/html/rfc7519)), который определяет компактный и автономный способ безопасной передачи информации между двумя взаимодействующими сторонами. Вы можете считать JWT улучшенной версией токенов для аутентификации.

Помните, что выше я говорил об использовании особой разновидности аутентификации с использованием токенов? Я имел ввиду JWT.

> Чтобы узнать больше о JWT и о том как они работают, прочитайте эту статью [Введение в JSON веб токены](https://tools.ietf.org/html/rfc7519).

## Почему JSON веб токены лучше, чем обычные токены

Существует несколько преимуществ при использовании JWT вместо обычных токенов:
1) JWT - это открытый стандарт. Это означает, что все реализации JWT должны быть достаточно однотипными, что является преимуществом при работе с разными языками и технологиями. Обычные токены не имеют жёсткой привязки к стандартам, что позволяет разработчику решать как лучше всего реализовать токены.
2) JWT могут содержать всю информацию о пользователе, что довольно удобно для клиента.
3) О сложностях, связанных с реализацией алгоритмов, не стоит беспокоиться, поскольку уже существуют готовые бибилиотеки. Использовать самописную систему аутентификации довольно небезопасно, поэтому здесь мы полагаемся "на проверенные в бою" библиотеки, которым можно доверять.

## Создаём модель User (Пользователь)

Не пора ли начать писать код?

В файле `conduit/apps/authentication/models.py` хранятся модели, которые мы будем использовать для аутентификации. Если Вы уже склонировали репозиторий, то наверное заметили, что каталог `conduit/apps/authentication/` уже существует. Но в нём нет файла `models.py`. Создайте его.

> В этом курсе мы специально довольно кратко рассматриваем каждый фрагмент кода. Мы уверены, что используя комментарии в коде и ресурсы, на которые мы даём ссылки, Вы сможете найти всю необходумую Вам информацию.

Нам нужно будет добавить следующие импорты для создания классов `User` и `UserManager`, поэтому добавьте следующий код в начало файла:

```python
import jwt

from datetime import datetime, timedelta

from django.conf import settings
from django.contrib.auth.models import (
    AbstractBaseUser, BaseUserManager, PermissionsMixin
)
from django.db import models
```
Настраивая аутентификацию в Django необходимо указать, что Вы используете свой, пользовательский класс `Manager` с двумя методами: `create_user` и `create_superuser`. Чтобы узнать как настроить аутентификацию в Django, прочитайте раздел [Замена стандартной модели User на созданную пользователем](https://docs.djangoproject.com/en/1.10/topics/auth/customizing/#substituting-a-custom-user-model).

Для начала создайте класс `UserManager`.

## Задаём параметр AUTH_USER_MODEL

## Создаём и запускаем миграции

## Наш первый пользователь

## Регистрируем новых пользователей

### RegistrationSerializer 

### RegistrationAPIView

## Регистрируем пользоваталей с помощью Postman

## Отображаем объекты User

## Реализация входа пользователей в систему

## LoginSerializer

## LoginAPIView

## Осуществляем вход пользователя в систему с помощью Postman

## Изменяем параметры EXCEPTION_HANDLER и NON_FIELD_ERRORS_KEY

## Обновляем UserJSONRenderer

## Получаем и обновляем информацию о пользователях

## UserSerializer

## UserRetrieveUpdateAPIView

## Аутентифицируем пользователей

## Сообщаем DRF о нашем бекэнде для аутентификации

## Осуществляем получение и обновление информации о пользователях с помощью Postman

## Переходим к более интересным темам

